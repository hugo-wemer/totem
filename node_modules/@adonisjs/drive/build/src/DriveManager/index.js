"use strict";
/*
 * @adonisjs/drive
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriveManager = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const manager_1 = require("@poppinss/manager");
const utils_1 = require("@poppinss/utils");
/**
 * Drive manager exposes the API to resolve disks and extend by
 * adding custom drivers
 */
class DriveManager extends manager_1.Manager {
    constructor(application, router, config) {
        super(application);
        this.application = application;
        this.router = router;
        this.config = config;
        /**
         * Find if drive is ready to be used
         */
        this.isReady = false;
        /**
         * The fake callback
         */
        this.fakeCallback = (_, disk, config) => {
            const { DriveFake } = require('../Fake');
            return new DriveFake(disk, config, this.router);
        };
        /**
         * Cache all disks instances
         */
        this.singleton = true;
        /**
         * Reference to registered fakes
         */
        this.fakes = new Map();
        this.validateConfig();
    }
    /**
     * Validate config
     */
    validateConfig() {
        if (!this.config) {
            return;
        }
        const validator = new utils_1.ManagerConfigValidator(this.config, 'drive', 'config/drive');
        validator.validateDefault('disk');
        validator.validateList('disks', 'disk');
        this.isReady = true;
    }
    /**
     * Returns the default mapping name
     */
    getDefaultMappingName() {
        return this.config.disk;
    }
    /**
     * Returns config for a given mapping
     */
    getMappingConfig(diskName) {
        return this.config.disks[diskName];
    }
    /**
     * Returns the name of the drive used by a given mapping
     */
    getMappingDriver(diskName) {
        return this.getMappingConfig(diskName)?.driver;
    }
    /**
     * Make instance of the local driver
     */
    createLocal(diskName, config) {
        const { LocalDriver } = require('../Drivers/Local');
        return new LocalDriver(diskName, config, this.router);
    }
    /**
     * Fake default or a named disk
     */
    fake(disk) {
        disk = disk || this.getDefaultMappingName();
        if (!this.fakes.has(disk)) {
            this.fakes.set(disk, this.fakeCallback(this, disk, this.getMappingConfig(disk)));
        }
    }
    /**
     * Restore the fake for the default or a named disk
     */
    restore(disk) {
        disk = disk || this.getDefaultMappingName();
        if (this.fakes.has(disk)) {
            this.fakes.delete(disk);
        }
    }
    /**
     * Restore all fakes1
     */
    restoreAll() {
        this.fakes = new Map();
    }
    /**
     * Resolve instance for a disk
     */
    use(disk) {
        if (!this.isReady) {
            throw new utils_1.Exception('Missing configuration for drive. Visit https://bit.ly/2WnR5j9 for setup instructions', 500, 'E_MISSING_DRIVE_CONFIG');
        }
        disk = disk || this.getDefaultMappingName();
        if (this.fakes.has(disk)) {
            return this.fakes.get(disk);
        }
        return super.use(disk);
    }
    /**
     * Register a custom fake implementation
     */
    setFakeImplementation(callback) {
        this.fakeCallback = callback;
    }
    /**
     * Returns the file contents as a buffer. The buffer return
     * value allows you to self choose the encoding when
     * converting the buffer to a string.
     */
    async get(location) {
        return this.use().get(location);
    }
    /**
     * Returns the file contents as a stream
     */
    async getStream(location) {
        return this.use().getStream(location);
    }
    /**
     * A boolean to find if the location path exists or not
     */
    exists(location) {
        return this.use().exists(location);
    }
    /**
     * Returns the location path visibility
     */
    async getVisibility(location) {
        return this.use().getVisibility(location);
    }
    /**
     * Returns the location path stats
     */
    async getStats(location) {
        return this.use().getStats(location);
    }
    /**
     * Returns a signed URL for a given location path
     */
    getSignedUrl(location, options) {
        return this.use().getSignedUrl(location, options);
    }
    /**
     * Returns a URL for a given location path
     */
    getUrl(location) {
        return this.use().getUrl(location);
    }
    /**
     * Write string|buffer contents to a destination. The missing
     * intermediate directories will be created (if required).
     */
    put(location, contents) {
        return this.use().put(location, contents);
    }
    /**
     * Write a stream to a destination. The missing intermediate
     * directories will be created (if required).
     */
    putStream(location, contents) {
        return this.use().putStream(location, contents);
    }
    /**
     * Not supported
     */
    setVisibility(location, visibility) {
        return this.use().setVisibility(location, visibility);
    }
    /**
     * Remove a given location path
     */
    delete(location) {
        return this.use().delete(location);
    }
    /**
     * Copy a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    copy(source, destination) {
        return this.use().copy(source, destination);
    }
    /**
     * Move a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    move(source, destination) {
        return this.use().move(source, destination);
    }
}
exports.DriveManager = DriveManager;
